(use-modules (ice-9 match)
             (ice-9 binary-ports)
             (ice-9 format)
             (rnrs bytevectors)
             ((rnrs io ports) #:select (call-with-bytevector-output-port))
             (srfi srfi-1)
             (ice-9 pretty-print))

(define (compile port)
  (define types '())
  (define funcs '())
  (define exports '())

  (define (intern-type! params results)
    (define type `(type (param ,@params)
                        (result ,@results)))
    (match (member type types)
      ((_ . tail) (length tail))
      (#f
       (let ((idx (length types)))
         (set! types (cons type types))
         idx))))

  (define (arg-type _) 'i32)

  (define (lookup-func name)
    (match funcs
      ((('func name* . _) . funcs)
       (if (eq? name name*)
           (length funcs)
           '()))))

  (define (add-func! name typeidx body)
    (set! funcs (cons `(func ,name ,typeidx ,body) funcs)))

  (define (add-export! name id)
    (set! exports (cons `(export ,name (func ,(lookup-func id))) exports)))

  (define (compile-def def)
    (define (args->env args) (reverse args))
    (match def
      (('define (f arg ...) exp)
       (add-func! f (intern-type! (map arg-type arg) '(i32))
                  (lambda () (compile-exp exp (args->env arg))))
       (add-export! (symbol->string f) f))))

  (define (compile-func func)
    (match func
      (('func name type compile-body)
       `(func ,type (local) ,@(compile-body)))))

  (define (compile-exp exp env)
    (let compile ((exp exp))
      (match exp
        ((? symbol? id)
         (match (memq id env)
           ((_ . tail) `((local.get ,(length tail))))))
        ((? exact-integer? n)
         `((i32.const ,n)))
        (('if test then else)
         `((block i32
                  (block ,@(compile test)
                         (br_if 0)
                         ,@(compile else)
                         (br 1))
                  ,@(compile then))))
        (('zero? exp)
         `(,@(compile exp)
           (i32.eqz)))
        (('- a b)
         `(,@(compile a)
           ,@(compile b)
           (i32.sub)))
        (('* a b)
         `(,@(compile a)
           ,@(compile b)
           (i32.mul)))
        ((f arg ...)
         (let ((idx (lookup-func f)))
           `(,@(append-map compile arg)
             (call ,idx)))))))

  (let lp ()
    (let ((datum (read port)))
      (unless (eof-object? datum)
        (compile-def datum)
        (lp))))

  (let ((funcs (map compile-func funcs)))
    (let ((types (reverse types))
          (funcs (reverse funcs))
          (exports (reverse exports)))
      (format #t "Assembling:\n~y\n" `(module ,@types ,@funcs ,@exports))
      (assemble types funcs exports))))

(define (assemble types funcs exports)
  (define (put-sleb out n)
    (if (let ((n* (+ n 64)))
          (eq? n* (logand n* #x7f)))
        (put-u8 out (logand n #x7f))
        (begin
          (put-u8 out (logior #x80 (logand n #x7f)))
          (put-sleb out (ash n -7)))))
  (define (put-uleb out n)
    (let ((next (ash n -7)))
      (if (zero? next)
          (put-u8 out n)
          (begin
            (put-u8 out (logior #x80 (logand n #x7f)))
            (put-uleb out next)))))
  (define (put-bytes out bytes)
    (put-uleb out (bytevector-length bytes))
    (put-bytevector out bytes))
  (define (put-section out id contents)
    (put-u8 out id)
    (put-bytes out contents))
  (define (put-vector out f elts)
    (put-uleb out (length elts))
    (for-each (lambda (elt) (f out elt)) elts))
  (define (put-vector-section out id f elts)
    (unless (null? elts)
      (put-section out id
                   (call-with-bytevector-output-port
                    (lambda (out)
                      (put-vector out f elts))))))
  (define (put-type out type)
    (match type
      ('i32 (put-u8 out #x7f))
      ('i64 (put-u8 out #x7e))
      ('f32 (put-u8 out #x7d))
      ('f64 (put-u8 out #x7c))
      (('type ('param p ...) ('result r ...))
       (put-u8 out #x60)
       (put-vector out put-type p)
       (put-vector out put-type r))))
  (define (put-func out func)
    (match func
      (('func typeidx . code)
       (put-uleb out typeidx))))
  (define (put-name out name)
    (put-bytes out (string->utf8 name)))
  (define (put-export out export)
    (match export
      (('export name ('func idx))
       (put-name out name)
       (put-u8 out #x00)
       (put-uleb out idx))))
  (define (put-block-body out body)
    (match body
      (((? symbol? type) body ...)
       (put-type out type)
       (put-expr out body))
      ((('type typeidx) body ...)
       (put-sleb out typeidx)
       (put-expr out body))
      (body
       (put-u8 out #x40)
       (put-expr out body))))
  (define (put-locals out locals)
    (match locals ; Only implemented for no locals.
      (() (put-vector out error '()))))
  (define (put-instruction out instr)
    (match instr
      (('block body ...)
       (put-u8 out #x02)
       (put-block-body out body))
      (('br_if labelidx)
       (put-u8 out #x0d)
       (put-uleb out labelidx))
      (('br labelidx)
       (put-u8 out #x0c)
       (put-uleb out labelidx))
      (('i32.eqz) (put-u8 out #x45))
      (('i32.sub) (put-u8 out #x6b))
      (('i32.mul) (put-u8 out #x6c))
      (('i32.const c)
       (put-u8 out #x41)
       (put-sleb out c))
      (('return)
       (put-u8 out #x0f))
      (('local.get idx)
       (put-u8 out #x20)
       (put-uleb out idx))
      (('call idx)
       (put-u8 out #x10)
       (put-uleb out idx))))
  (define (put-expr out instrs)
    (for-each (lambda (instr) (put-instruction out instr)) instrs)
    (put-u8 out #x0b))
  (define (put-code out func)
    (match func
      (('func typeidx ('local t ...) . code)
       (put-bytes out
                  (call-with-bytevector-output-port
                   (lambda (out)
                     (put-locals out t)
                     (put-expr out code)))))))

  (call-with-bytevector-output-port
   (lambda (out)
     (put-bytevector out #vu8(#x00 #x61 #x73 #x6D)) ; magic
     (put-bytevector out #vu8(#x01 #x00 #x00 #x00)) ; version
     (put-vector-section out 1 put-type types)
     (put-vector-section out 3 put-func funcs)
     (put-vector-section out 7 put-export exports)
     (put-vector-section out 10 put-code funcs))))

(when (batch-mode?)
  (match (command-line)
    ((_ in out)
     (let ((bv (call-with-input-file in compile)))
       (call-with-output-file out (lambda (port) (put-bytevector port bv)))))
    ((prog . _)
     (format (current-error-port) "usage: ~a in.scm out.wasm\n" prog)
     (exit 1))))
